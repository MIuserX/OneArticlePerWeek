## 原文链接

https://www.enterprisedb.com/postgres-tutorials/history-improvements-vacuum-postgresql



## 翻译



​		当我开始使用 PostgreSQL 的时候，`autovacuum` 还不存在，也没意识到需要手动VACUUM。几个月后，我想直到为什么我的数据库这么慢。在 cron 任务里加了 `vacuumdb` 命令，每 6 小时运行一次，这对我那时面对的问题很有效，但这个方法奏效，只是因为我的数据库很小并且只有很少的流量。在大部分环境中，`UPDATE` 和 `DELETE` 操作对某些表比其他表更频繁，这些表将会比其他表更跨地积累死亡元组，因此 `VACUUM` 之间地间隔也各种各样。如果一个碰到这种环境的用户执行 full-database 的 `VACUUM` 足够频繁来满足那些更新最重的表的需求，这也会对那些更新轻的表进行了超过必要的 `VACUUM`，浪费效力。如果减少了 full-database `VACUUM` 的频率来避免浪费效力，重更新的表将无法被足够的 `VACUUM` 并且占用的磁盘空间持续增长直到他们被死亡元组填满，或被称作 “溢出”。

​		PG 8.3 是第一个带有合理的现代化的 `autovacuum` 的发布。`autovacuum` 首次被默认允许。`autovacuum` 也具有了多进程架构，意味着可以同时对多个表进行 `VACUUM`。当然，`autovacuum` 负责计算出哪些表要进行 `vacuum`，大大地（虽然不完全）消除了手动 `vacuum` 的需要。这是一个巨大的进步；PG 用户首次无需在配置 PG 时考虑配置 `VACUUM`。运气好的时候，它可以开箱即用完美地工作。

​		PG 8.4 带来了两项巨大的改进。在老版本中，存在一个固定大小的 free space map，这个 free space map 可以通过改变配置参数并重启来改变大小。如果数据库中的具有空闲空间的页的数量达到配置的 free space map 的大小，服务器将失去对某些包含空闲空间的页的跟踪，典型问题是 runaway database bloat。PG 8.4 引入了一个新的、动态调整大小的 free space map，这将不会丢失对空闲空间的跟踪。PG 8.4 还增加了一个 visibility map，使新的 `VACUUM` 不用再扫描表的未修改的部分。然而，每次扫描整个索引仍然是必要的，周期性的扫描劝全表是必须的，为了防止事务ID回卷。一般防止事务ID回卷的 `VACUUM` 是非常稀少的，相较于原初 `VACUUM`；默认情况下，前者被触发在每 200 million 个写事务，后者被触发当表中死亡元组的数量到达 500 + (表的估算元组数 * 20%)。在每种情况下，这些值可以通过修改配置参数来改变。

​		从 PG 8.4 以来，好几个改进都聚焦于：尝试防止 `VACUUM` 卡住。存在于 `VACUUM` 的多个变种中的基本问题是：如果一个 `autovacuum` 进程在等待一些等待了很长时间都无法获得的锁，这时

(1) 尝试 `VACUUM` 的表没有被这个进程或其他进程 `VACUUM` ，因为一个时刻对于一个表仅允许有一个进程进行 `VACUUM`

(2) 在系统中只存在少量的几个可用的 `autovacuum` 进程在 `VACUUM` 其他表，这可能意味着其他的表也没有被迅速地 `VACUUM`

这两个问题都可以导致数据表膨胀。PG 9.1 通过让 `autovacuum` 跳过那些需要 `VACUUM` 但无法立刻获取表锁的表对这个问题进行了一些缓解；因为 `autovacuum` 每分钟重试一次，这不会造成什么害处。PG 9.2 也做了一些改进，系统会跳过单个表的一些 block ，当无法立刻获取 cleanup lock 时，除非这个 block 包含需要删除的元组或需要冻结的元组的情况 和 `VACUUM` 是为了防止事务ID回卷的情况。PG 9.5 减少了  btree 索引 index scan 时在最后一个访问的 index page 上留一个 PIN 标记的情况，这消除了大量的 `VACUUM` 因为 index scan 而卡住的情况。上面描述的改进的情况很清晰，index scan 卡住的问题没有被完全解决，但是我们稳定了减少了这个问题发生的场景。

​		也存在一些致力于减少 `VACUUM` 扫描每个 heap page 的次数的改进。在 PG 9.3 之前，一个在两次 `VACUUM` 之间没有被修改的表 page 将会被第二个 `VACUUM` 标记为 all-visible ，并会被之后的 `VACUUM` 跳过，除非是被触发来防止事务ID回卷的 `VACUUM`。在 PG 9.6，被触发来防止事务ID回卷的 `VACUUM` 也可以跳过页。要做到这个，visibility map 别深入改进来保持不仅跟踪是否页是 all-visible(这是说，没有包含任何死亡元组)，还跟踪它们是否是 all-frozen(这是说，不包含任何可能导致事务ID回卷风险的元组)。在后一种策略中的页可以被无条件地跳过；它们不能被 `VACUUM` 以任何目的而感兴趣。

​	除了上面提到的之外，还存在一个稳定的流，来记录改进和一些其他的有效的改进，这些年。

​	接下来该做什么呢？PG 开发社区取得了巨大的进步，在减少 `VACUUM` 对表执行不必要的扫描的程度上，但是基本上一点也没进步在避免对索引不必要的扫描。例如，甚至一个发现没有死亡元组的 `VACUUM` 仍然会扫描 btree 索引来循环空页。改进这个问题的工作正在进行，但在一些关于 btree 索引如何与事务ID回卷的细节上磕磕绊绊。还有个期待的改进是：改进在 存在一些，但不是很多死亡元组的 情况下的行为。如果 1TB 