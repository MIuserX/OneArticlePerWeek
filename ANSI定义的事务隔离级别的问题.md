11:11 - 12:00

16:06 - 17:54

链接：https://www.alibabacloud.com/blog/comprehensive-understanding-of-transaction-isolation-levels_596894



​		大部分开发者对事务隔离级别比较熟悉，并且知道基本的概念，像脏读、不可重复读、读已提交、可重复读。然而，开发者，作为技术个人，也必须对事务隔离级别有一个更深的理解。如果只有事务隔离级别的基础知识，数据库内核开发者可能开发出令人困惑的隔离级别，并且业务开发者可能从数据库得到非预期的结果。

​		要确认你是否对事务隔离级别有一个深入的理解，问自己几个问题：

（1）什么是事务隔离级别？它解决了什么问题？事务隔离级别被清楚的定义了吗？定义精确吗？

（2）主流数据库事务隔离级别的实现性能怎么样，如 MySQL、Oracle，它们如何实现的？它们的定义与 “官方定义” 一致吗？



​		如果你清楚地回答了上面几个问题，那祝贺你，你确实对事务隔离级别有一个深入的理解。如果不，不要担心。在读了这篇文章后，你将会得到这些问题的答案。



## Section 1：事务隔离级别

​		事务隔离级别是关系型数据库的 ACID（atomicity - 原子性，consistency - 一致性，isolation - 隔离性，durability - ）中的 I，保证并发事务的冲突安全。SQL 92 定义了三个并发事务可能造成的现象：

* **脏读**：事务 T1 修改了一个行。事务 T2 在事务 T1 提交之前读取到了这个行。如果 T1 执行了回滚，T2 就读取到了一个未被提交过的行(这个行被认为是不存在的)。
* **不可重复读**：事务 T1 读取了一个行。然后事务 T2 修改或删除了这个行并提交。如果 T1 再去读这个行，它可能会发现这个行被删除了或读到了修改后的值。
* **幻读**：事务 T1 读到了满足一些条件的若干行 N。然后，事务 T2 生成了一些满足同样条件的若干行。如果 T1 再读，将会获得一个不同的行的集合。 



​		如果你认为前面的定义太长，看看下面的形式：

```
A1 Dirty read: w1[x] ... r2[x] ... (a1 and c2 in any order)
A2 Fuzzy read: r1[x] ... w2[x] ... c2 ... r1[x] ... c1
A3 Phantom read: r1[P] ... w2[y in P] ... c2 ... r1[P] ... c1
```

​		w1[x] 表示事务1写了记录 x。r1[x] 表示事务1读取了记录x。c1 表示事务1已提交。a1 表示事务1已回滚。r1[P] 表示事务1读取了根据条件P读到了几行。w1[y in P] 表示事务1写了记录 y，也是符合条件 P 的。

​		根据前面的小星星描述，ANSI 定义了四个隔离级别来解决这三个现象。

**Table 1** ANSI 根据三种现象定义的隔离级别

| 隔离级别             | P1(或A1)脏读 | P2(或A2)不可重复读 | P3(或A3)幻读 |
| -------------------- | ------------ | ------------------ | ------------ |
| ANSI READ UNCOMMITED | 可能         | 可能               | 可能         |
| ANSI READ COMMITED   | 不可能       | 可能               | 可能         |
| ANSI REPEATABLE READ | 不可能       | 不可能             | 可能         |
| ANOMALY SERIALIZABLE | 不可能       | 不可能             | 不可能       |

​		然而，Jim Gray，在他著名的论文 “A Critique of ANSI SQL Isolation Levels” (Critique for short)，争论说：根据前述的三种现象定义隔离级别是不严谨的，原因如下：

#### Reason 1

如果 P1、P2、P3 被禁止，可序列化级别可能被达到。然而，ANSI 标准明确描述可序列化级别为 “执行多个并发事务的效果等价于一个确定的序列”。这两个是矛盾的。当事务 P1、P2 或 P3 被禁止，“等价于一个确定的序列” 可能无法达到。这个严谨的定义把 ANSI 标准中的 P1、P2 和 P3 被禁止的级别叫做异常的序列化。

#### Reason 2 

现象的定义是不精确的。如下表所示，这个例子不包含在 A1 中，但存在脏读(Txn2 读到了 x + y != 100)。对于 A2 和 A3，也存在相似的例子。感兴趣的读者可以尝试列出一些列子。这里不再细说。

>x = 50，y = 50，Txn1 从 x 向 y 转了40元。
>
>| Txn1                               | Txn2                       |
>| ---------------------------------- | -------------------------- |
>| r1[x = 50]<br />w1[x = 10]         |                            |
>|                                    | r2[x = 10]<br />r2[y = 50] |
>| r1[y = 50]<br />w1[y = 90]<br />c1 |                            |
>|                                    | c2                         |

​		ANSI 严格地定义了现象。如果事务的提交、回滚、数据查询域都被移除，只剩下并发事务的读写序列，更不严格又更精确的现象定义是：

```
P1 Dirty Read: w1[x]...r2[x]...(c1 or a1)
P2 Fuzzy Read: r1[x]...w2[x]...(c1 or a1)
P3 Phantom: r1[P]...w2[y in P]...(c1 or a1)
```

#### Reason 3

这3个现象仅应用于 S(ingle) V(alue) 系统，并且不能定义 M(ulti) V(ersion) 系统的隔离级别。很多商业数据库实现的快照隔离(SI，snapshot isolation)  不禁止 P1、P2 和 P3，但可能禁止约束，可能无法序列化。除了 P1、P2 和 P3，其他现象包括：

```
P4 Lost update: r1[x]...w2[x]...w1[x]...c1
A5A Read skew: r1[x]… w2[x]... w2[y]… c2… r1[y]… (c1 or a1)
A5B Write skew: r1[x]… r2[y]… w1[y]… w2[x]… (c1 and c2 occur)
A5B2 Write skew 2: r1[P]... r2[P]… w1[y in P]... w2[x in P]...(c1 and c2 occur)
```



​		我将会为每种现象给出一个例子：

```
r1[x=50] r2[x=50] w2[x=60] c2 w1[x=70] c1
```

**Lost update(丢失更新)**：事务1和2分别转了金额 20 和金额 10，对于账户 x。当事务1提交之后，金额 70 被写入数据库。在事务2提交之后，金额70被金额60覆盖。在事务1和2提交后，账户应该有金额80。



```
(x+y=100) r1[x=50] w2[x=10] w2[y=90] c2 r1[y=90] c1
```

**Read skew(读取错位)**：账户 x 和 y 的余额都是 50，一共是 100。事务1读取 x(x=50) 后，事务2从 x 转了40到 y。在事务2提交后，事务1读取了账户 y(y=90)。对于事务1，x+y=140，导致不一致性。



```
(x+y>=60) r1[x=50] r2[y=50] w1[y=10] c1 w2[x=10] c2
```

**Write skew(写错位)**：账户 x 和 y 的余额都是 50，一共是 100。存在一个约束，账户 x 和 y 金钱总额必须是 60 或更多。事务1和事务2读取账户 x 和 y，分别从 x 向 y 转 40，并且认为它们没有打破约束。当两个事务被提交，x + y = 20，约束被打破。



```sql
(count(P)<=4):r1[count(P)=3],r2[count(P)=3],insert1[x in P],insert2[y in P],c1,c2,
```

**Write skew 2**：改变 Write skew 条件到域。



## Section 2：隔离级别的实现

​		前面的小节描述了 ANSI 定义的3种现象。





## Section 3：MySQL(x-Engine) 隔离级别实现

